{"version":3,"file":"main-bundle.js","sources":["webpack:///./app/models/Parser.js","webpack:///./~/object-assign/index.js","webpack:///./~/react-dom/lib/isEventSupported.js"],"sourcesContent":["import Baby from 'babyparse';\nimport fs from 'fs';\n\n/**\n* Colors for bounding boxes\n* TODO: Have less similar colors / better way for choosing\n*/\nexport const COLORS = {\n  0: 'green',\n  1: 'red',\n  2: 'blue',\n  3: 'yellow',\n  4: 'orange',\n  5: 'purple',\n  6: 'black',\n  7: 'white',\n  8: 'pink',\n  9: 'cyan',\n  10: 'darkgreen',\n  11: 'gold',\n  12: 'navy',\n  13: 'springgreen',\n  14: 'yellowgreen',\n  15: 'rosybrown',\n  16: 'royalblue',\n  17: 'saddlebrown',\n  18: 'salmon',\n  19: 'sandybrown',\n  20: 'seagreen',\n  21: 'seashell',\n  22: 'sienna',\n  23: 'silver',\n  24: 'skyblue',\n  25: 'slateblue',\n  26: 'slategray',\n  27: 'snow',\n  28: 'steelblue',\n  29: 'tan',\n  30: 'teal',\n  31: 'thistle',\n  32: 'tomato',\n  33: 'turquoise',\n  34: 'violet',\n  35: 'wheat',\n  36: 'lawngreen',\n  37: 'lemonchiffon',\n  38: 'lightblue',\n  39: 'lightcoral',\n  40: 'lightcyan',\n  41: 'lightpink',\n  42: 'lightsalmon',\n  43: 'lightseagreen',\n  44: 'lightyellow',\n  45: 'lime',\n  46: 'magenta',\n  47: 'maroon',\n  48: 'mediumblue',\n  49: 'mediumpurple',\n  50: 'mediumseagreen',\n};\n\nclass BoundingBox {\n  constructor(id, x, y, width, height, theta) {\n    this.color = COLORS[id];\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.theta = theta;\n    this.theta_in_radians = theta * (Math.PI / 180);\n\n    this.rotatePoint = this.rotatePoint.bind(this);\n    this.collidesWith = this.collidesWith.bind(this);\n  }\n\n  /**\n  * Determines whether a given point collides with this bounding box\n  * @param otherX the x coor of the point\n  * @param otherY the y coor of the point\n  * return true if it collides, false otherwise\n  */\n  collidesWith(otherX, otherY) {\n    const { rotatedX, rotatedY } = this.rotatePoint(\n      otherX - this.x,\n      otherY - this.y\n    );\n\n    return (rotatedX < (this.width / 2))\n        && (rotatedX > -(this.width / 2))\n        && (rotatedY < (this.height / 2))\n        && (rotatedY > -(this.height / 2));\n  }\n\n  /**\n  * Helper function to rotate a point to the bounding boxes\n  * reference Frame\n  */\n  rotatePoint(x, y) {\n    const rotatedX = (x * Math.cos(this.theta_in_radians))\n        + (y * -Math.sin(this.theta_in_radians));\n    const rotatedY = (x * Math.sin(this.theta_in_radians))\n        + (y * Math.cos(this.theta_in_radians));\n    return { rotatedX, rotatedY };\n  }\n\n}\n\nexport default class Parser {\n\n  constructor(url, completedCallback) {\n    this.finish = this.finish.bind(this);\n    this.data = [];\n    this.callback = completedCallback;\n\n    fs.readFile(url, 'utf8', (err, data) => {\n      Baby.parse(data, {\n        delimiter: ',',\n        header: true,\n        dynamicTyping: true,\n        complete: this.finish,\n      });\n    });\n\n    this.getFrame = this.getFrame.bind(this);\n    this.update = this.update.bind(this);\n  }\n\n  /**\n   * Call back from babyparse that will actually parse the results\n   * into BoundingBoxes and store them into this.data\n   */\n  finish(results) {\n    let boundingBoxes = [];\n    const data = results.data;\n    console.log(results);\n\n    boundingBoxes.push(new BoundingBox(\n      data[0].target_id,\n      data[0].x,\n      data[0].y,\n      data[0].width,\n      data[0].height,\n      data[0].theta,\n    ));\n\n    for (let i = 1; i < results.data.length; i += 1) {\n      const box = new BoundingBox(\n        data[i].target_id,\n        data[i].x,\n        data[i].y,\n        data[i].width,\n        data[i].height,\n        data[i].theta,\n      );\n      if (data[i].frame_num === data[i - 1].frame_num) {\n        boundingBoxes.push(box);\n      } else {\n        this.data.push(boundingBoxes);\n        boundingBoxes = [];\n        boundingBoxes.push(box);\n      }\n    }\n    console.log(this.data.length);\n    this.callback();\n  }\n\n  /**\n  * @param frame the frame number to get bounding boxes for\n  * @return an array of bounding boxes for the given frame\n  */\n  getFrame(frame) {\n    if (frame < 0 || frame > this.data.length) {\n      return null;\n    }\n    return this.data[frame];\n  }\n\n  /**\n  * Updates all bounding boxes based on a given correction. From the\n      corrections starting frame, every box with the oldId will be\n      updated to have the newId and corresponding color\n  * @param correction, a correction contains an frame, oldId, and newId\n  */\n  update(correction) {\n    for (let i = correction.frame; i < this.data.length; i++) {\n      for (let j = 0; j < this.data[i].length; j++) {\n        if (correction.oldId == this.data[i][j].id) {\n          this.data[i][j].id = correction.newId;\n          this.data[i][j].color = COLORS[correction.newId];\n        }\n      }\n    }\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/models/Parser.js","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-assign/index.js\n// module id = ./node_modules/object-assign/index.js\n// module chunks = 0 1","/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature = document.implementation && document.implementation.hasFeature &&\n  // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nmodule.exports = isEventSupported;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/react-dom/lib/isEventSupported.js\n// module id = ./node_modules/react-dom/lib/isEventSupported.js\n// module chunks = 0 1"],"mappings":"AAoGA;;;;ACxFA;;;;;;;;;;;;;ACIA","sourceRoot":""}